# ARCHITECTURE.md — CLI Interpreter (C++)

## 1. Назначение и область проекта

Проект реализует простой интерпретатор командной строки (mini-shell), поддерживающий:

**Встроенные команды (builtins):**
- `cat` — вывести содержимое файла(ов) или stdin;
- `echo` — вывести аргументы;
- `wc` — вывести количество строк, слов и байт (по файлу или stdin);
- `pwd` — распечатать текущую директорию;
- `exit` — выйти из интерпретатора (с опциональным кодом).

**Синтаксис и механики shell-подобного поведения:**
- одинарные и двойные кавычки:
  - single quotes `'...'` = strong quoting (никаких подстановок, всё буквально);
  - double quotes `"..."` = weak quoting (подстановка `$` разрешена);
- окружение: команды вида `NAME=VALUE` (присваивания переменных окружения);
- подстановка переменных: оператор `$NAME`;
- запуск внешних программ, если команда неизвестна интерпретатору;
- пайплайны: оператор `|`.

Примеры корректного поведения:
- `echo "Hello, world!"` → `Hello, world!`
- `FILE=example.txt` (сохраняет переменную в окружении shell)
- `cat $FILE` → содержимое `example.txt`
- `cat example.txt | wc` → `1 3 18`
- `echo 123 | wc` → `1 1 3`
- `x=ex y=it` затем `$x$y` → `exit`

## 2. Нефункциональные требования и принципы проектирования

Требования к архитектуре:
- легко добавлять новые команды;
- чёткое разграничение ответственности;
- компонентная структура (не «клубок классов»);
- подробное словесное описание работы системы.

Основные архитектурные принципы:
1. **Разделение на этапы**: ввод строки → лексический анализ + подстановки → синтаксический анализ (пайпы) → объектное представление (AST/IR) → исполнение.
2. **Подстановка до токенизации**: подстановки `$NAME` выполняются при сборке *слов* во время лексического анализа (с учётом кавычек), а не «после split по пробелам».
3. **Builtins и состояние shell**:
   - builtins исполняются в процессе shell, если команда одиночная (без пайпа) и должна менять состояние (`exit`, присваивания);
   - builtins внутри пайпа исполняются в дочернем процессе, чтобы корректно работали pipe/dup2 и чтобы `exit` не завершал родителя.
4. **Многопоточность не используется**: пайпы реализуются классическим POSIX способом `pipe` + `fork` + `dup2` + `execve` + `waitpid`.
5. **RAII и безопасность ресурсов**: файловые дескрипторы управляются аккуратно (закрытие лишних fd, без утечек).

## 3. Диаграммы архитектуры

Для наглядности архитектурные решения дополнительно представлены в виде диаграмм.
Исходные схемы вынесены в отдельный файл:

[diagrams_source_mermaid.md](diagrams_source_mermaid.md)

В нём содержатся следующие диаграммы:

### 1. Component Diagram

Отражает общую компонентную структуру системы.  
Показывает основные модули интерпретатора (Shell, Frontend, Executor, Environment, Builtin Registry, AST) и направления их взаимодействия.  
Используется для демонстрации разграничения ответственности между подсистемами и принципа «проектирование сверху вниз».

### 2. Main Flow Diagram

Показывает поток исполнения программы от точки входа `main` до завершения работы интерпретатора.  
Диаграмма отражает цикл чтения пользовательского ввода, этапы парсинга, обработки ошибок, исполнения команд и корректного завершения по `exit` или EOF.  
Используется для прослеживаемости логики выполнения и точек принятия решений.

### 3. Lexer State Machine

Представляет лексический анализ в виде конечного автомата.  
Отражает переходы между состояниями `Normal`, `Single Quote` и `Double Quote`, а также правила обработки пробелов, символа `|` и подстановок `$VAR`.  
Демонстрирует, что подстановка переменных выполняется на этапе построения слов, а не после токенизации.

### 4. AST Structure Diagram

Отражает объектную модель результата разбора командной строки.  
Показывает структуры `Pipeline`, `CommandSpec` и `Assignment`, а также их композиционные связи.  
Иллюстрирует то, как команды и пайплайны представлены во внутреннем виде перед этапом исполнения.

### 5. Pipes / File Descriptors Diagram

Иллюстрирует механизм организации пайплайнов на уровне процессов и файловых дескрипторов.  
Показывает, каким образом `stdout` одной команды соединяется со `stdin` следующей через системные вызовы `pipe` и `dup2`.  
Подчёркивает разделение аргументов команды и входного потока данных.

### 6. Builtin vs External Diagram

Отражает логику выбора способа исполнения команды.  
Показывает различие между встроенными командами (выполняются внутри интерпретатора или в дочернем процессе при пайплайне) и внешними программами, запускаемыми через системный вызов `exec`.  
Диаграмма демонстрирует, что интерпретатор не исполняет внешний код самостоятельно, а передаёт управление операционной системе.

## 4. Модель данных (объектное представление результата разбора)

### 4.1 Pipeline

`Pipeline` описывает одну строку пользователя: набор команд, соединённых `|`.

```cpp
struct Pipeline {
    std::vector<CommandSpec> commands; // минимум 1
};
```

Гарантии:
- `commands.size() >= 1` для непустой строки (после trim).
- Наличие `|` приводит к `commands.size() > 1`.

### 4.2 CommandSpec

`CommandSpec` описывает одну команду в пайплайне.

```cpp
struct CommandSpec {
    std::vector<std::string> argv;      // argv[0] = имя команды
    std::vector<Assignment> prefix_env; // присваивания перед командой (задел под расширение)
    bool is_assignment_only = false;    // true, если команда состоит только из присваиваний
};
```

Инварианты:
- Если `is_assignment_only == false`, то `argv.size() >= 1`.
- Если `is_assignment_only == true`, то `argv` пуст или игнорируется; `prefix_env` содержит хотя бы одно присваивание.
- В минимальном наборе требований поддерживается `NAME=VALUE` **только как отдельная команда-оператор** (без имени команды).
- Поле `prefix_env` — архитектурный задел для будущего `NAME=VALUE cmd ...`; в версии 1 префиксные присваивания не формируются.
- В v1 `Parser` не заполняет `prefix_env`; `Executor` поддерживает overlay, но поле почти всегда пустое.

### 4.3 Assignment

```cpp
struct Assignment {
    std::string name;  // [A-Za-z_][A-Za-z0-9_]*
    std::string value; // после обработки кавычек и $ подстановок
};
```

Семантика:
- `NAME=VALUE` в строке без команды обновляет `Environment` интерпретатора.
- Если встречено `NAME=` — значение становится пустой строкой.

## 5. Frontend: лексический анализ, кавычки и подстановки, синтаксис пайпов

### 5.1 Задача Frontend

Frontend отвечает за:
- корректное распознавание границ слов (аргументов) с учётом кавычек;
- распознавание `|` как оператора пайпа только вне кавычек;
- выполнение подстановок `$NAME` с учётом режима quoting;
- построение `Pipeline` / `CommandSpec` / `Assignment`;
- валидацию базовых ошибок синтаксиса (незакрытые кавычки, `|` без команды).

### 5.2 Lexer: состояния и токены

#### Состояния лексера
- `Normal`: обычный режим.
- `InSingleQuote`: внутри `'...'` (strong quoting).
- `InDoubleQuote`: внутри `"..."` (weak quoting).

#### Токены
- `WordToken{text, assignment_eq}`: готовое слово (аргумент) после снятия кавычек и выполнения подстановок.
  - `assignment_eq == true` означает, что лексер встретил символ `=` **в незакавыченной части** слова и до этого `=` не было quoted-фрагментов в *имени* (то есть слово может быть кандидатом на присваивание `NAME=VALUE`).
  - Это позволяет отличать случаи вроде `"A=B"` и `"A"=B` (не присваивания) от `A="B"` (присваивание).
- `Pipe`: символ `|` вне кавычек.
- `End`: конец ввода.

Лексер не выдаёт «сырые» токены по символам. Его задача — **собрать корректные слова**.

### 5.3 Правила quoting

- В `Normal`:
  - пробел/табуляция разделяют слова;
  - `'` открывает/закрывает single-quoted часть;
  - `"` открывает/закрывает double-quoted часть;
  - `|` является токеном `Pipe` (если слово уже копится — слово завершается, затем выдаётся `Pipe`).
- В `InSingleQuote`:
  - все символы добавляются буквально, включая `$` и `|`;
  - выход по следующему `'`.
- В `InDoubleQuote`:
  - все символы добавляются, кроме `"` (закрывает кавычки);
  - подстановка `$NAME` разрешена;
  - `|` не считается пайпом.

Дополнение (пустые аргументы):
- `""` и `''` создают **пустой аргумент**: `WordToken{text:"", assignment_eq:false}`.

### 5.4 Подстановка переменных `$NAME`

Подстановка производится **на этапе лексера при сборке слова**, что удовлетворяет требованию «подстановка до токенизации».

Правило:
- если встречен символ `$` **и мы не в `InSingleQuote`**, пробуем прочитать имя переменной:
  - имя: `[A-Za-z_][A-Za-z0-9_]*`;
  - если имя не читается (например, `$` в конце строки или `$` перед пробелом), `$` трактуется как обычный символ (осознанное упрощение).
- значение берётся из `Environment`. Если переменная отсутствует — подставляется пустая строка.

Примеры:
- `cat $FILE` → подставится значение `FILE`
- `"a$Xb"` → подстановка внутри double quotes
- `'$X'` → остаётся `$X` без подстановки

### 5.4.1 Примеры склейки частей слова и крайних случаев `$`

Слова могут состоять из нескольких подряд идущих «фрагментов» (обычный текст + quoted-фрагменты), при этом результатом будет **одно** `Word`:

- `ab"cd"ef` → одно слово `abcdef`
- `a'$X'b` → одно слово `a$Xb` (внутри single quotes подстановки нет)
- `"a"'b'"c"` → одно слово `abc`

Крайние случаи для `$` (в версии 1):
- `echo $` → печатает `$` (имя переменной отсутствует)
- `echo $1` → печатает `$1` (после `$` имя переменной не читается по правилу `[A-Za-z_][A-Za-z0-9_]*`)
- `echo "$"` → печатает `$`
- `echo "$X"` → делает подстановку (если `X` есть в окружении)


### 5.5 Parser: грамматика и построение AST

Синтаксис верхнего уровня:

```text
line       := pipeline | empty
pipeline   := command ( '|' command )*
command    := (word)+
word       := WordToken token from lexer
```

Построение `CommandSpec`:
- парсер получает поток токенов `WordToken / Pipe / End`;
- команда — это последовательность `WordToken` до `Pipe` или `End`;
- внутри команды слова вида `NAME=VALUE` распознаются как присваивания, если:
  - `WordToken.assignment_eq == true` (то есть «разделяющий» `=` был в незакавыченной части, а имя не содержало quoted-фрагментов);
  - в тексте есть символ `=` и он не первый;
  - `NAME` соответствует `[A-Za-z_][A-Za-z0-9_]*`.
  Если `assignment_eq == false`, слово трактуется как обычный аргумент, даже если после снятия кавычек текст выглядит как `NAME=VALUE`.
- если команда содержит только присваивания и не содержит других слов → `is_assignment_only = true`, `prefix_env = assignments`.

Ошибки синтаксиса:
- `|` в начале строки или `||` или `cmd | | cmd` → ошибка `missing command around pipe`.
- незакрытые кавычки → ошибка `unterminated quote`.

Поведение на пустую строку:
- если после trim строка пустая → Frontend возвращает “no-op”, Executor не вызывается.

## 6. Environment: хранение и модификация окружения

### 6.1 Назначение

`Environment` хранит переменные shell. Он нужен для:
- подстановок `$NAME` в Frontend;
- присваиваний `NAME=VALUE`;
- формирования окружения для `execve` внешних программ.

### 6.2 Интерфейс

```cpp
class Environment {
public:
    std::string get(const std::string& name) const;         // отсутствует -> ""
    bool has(const std::string& name) const;

    void set(const std::string& name, std::string value);   // обновить/создать

    // Для execve: возвращает массив строк "NAME=VALUE"
    std::vector<std::string> snapshot() const;

private:
    std::unordered_map<std::string, std::string> vars_;
};
```

### 6.3 Инициализация

На старте shell копирует текущее окружение процесса (`environ`) в `vars_`. Это гарантирует, что внешние программы запускаются с привычной средой.

### 6.4 Семантика присваиваний

- Команда `NAME=VALUE` без других слов обновляет `vars_` в родительском процессе.
- Если присваивание выполняется в дочернем процессе (например, внутри pipeline), оно не влияет на окружение родителя.
- `NAME=VALUE cmd args...` (префиксные присваивания для одной команды) **в первой версии не поддерживаются**.
  Поле `prefix_env` существует как задел: при расширении оно будет применяться как временное окружение только для одной команды и не меняет `Environment` shell.

## 7. Executor: исполнение команд, пайпы, builtins и внешние программы

### 7.1 Результат исполнения

```cpp
struct ExecResult {
    int exit_code;     // 0..255
    bool request_exit; // true, если нужно завершить REPL (только builtin exit в parent)
};
```

### 7.1.1 План выполнения и «создание команд»

Термин «создание команды» в рамках исполнения понимается как построение плана запуска из результата парсинга.
Перед реальным `fork/exec/dup2` `Executor` преобразует каждый `CommandSpec` в `ExecUnit`:

```cpp
enum class ExecKind { AssignmentOnly, Builtin, External };

struct ExecUnit {
    ExecKind kind;
    std::vector<std::string> argv;       // для Builtin/External
    std::vector<Assignment> prefix_env;  // overlay окружения для этой команды (может быть пустым)
};
```

Правила определения `kind`:
- если `CommandSpec.is_assignment_only == true` → `AssignmentOnly`;
- иначе если `argv[0]` найден в `BuiltinRegistry` → `Builtin`;
- иначе → `External`.

Дальнейшие ветки (`fork`, `execve`, запуск builtin) работают уже с `ExecUnit`. Это фиксирует точку, где принимается решение builtin/external/assignment, и делает расширение поведения (например, поддержка `NAME=VALUE cmd ...`) локальным для этапа построения плана.

### 7.2 Выбор: builtin vs external

`Executor` определяет тип команды по `argv[0]`:
- если имя присутствует в `BuiltinRegistry` → builtin;
- иначе → внешняя программа.

Важно: запуск внешней программы делается через POSIX `exec*` (передача управления ОС), без попыток «исполнять внешний код» внутри интерпретатора.

### 7.2.1 Резолвинг внешней команды и окружение для `execve`

Цель: внешние программы должны запускаться **с окружением, модифицированным внутри shell** (через `NAME=VALUE`).

Поэтому в child-процессе:

1) формируем **эффективное окружение команды**:
   - берём базу из `Environment` (снимок `NAME=VALUE`);
   - если у команды есть `prefix_env` — накладываем присваивания поверх базы (overlay) **только для этой команды**;
     в версии 1 `prefix_env` обычно пуст, но точка расширения уже зафиксирована.

2) строим `envp` (массив `char* const`) из эффективного окружения и запускаем резолвинг/`execve`.

#### EnvpBuilder (lifetime для `execve`)

Для корректного вызова `execve` нужен массив указателей `char* const envp[]`, при этом строки должны жить до момента вызова.

Рекомендуемая утилита:
- хранит `std::vector<std::string> env_strings` со строками `NAME=VALUE`;
- параллельно собирает `std::vector<char*> env_ptrs`, где каждый элемент указывает на `env_strings[i].data()`/`c_str()`;
- добавляет завершающий `nullptr` в `env_ptrs`;
- гарантирует, что `env_strings` и `env_ptrs` находятся в области видимости до `execve`.

Дальше:
3) резолвим путь до исполняемого файла **по `PATH` из эффективного окружения**;
4) вызываем `execve(path, argv, envp)`.

Правило резолвинга:
- если `argv[0]` содержит символ `'/'` → считаем это путём и пробуем `execve(argv[0], argv, envp)`;
- иначе:
  - берём `PATH` из `Environment` (если отсутствует — считаем его пустым);
  - делим `PATH` по `:` на директории;
  - по очереди пробуем `execve(dir + "/" + argv[0], argv, envp)`.

Ошибки резолвинга:
- если все попытки завершились `ENOENT` → команда не найдена, код `127`;
- если встретилась ошибка «файл найден, но нельзя исполнить» (`EACCES`, `ENOEXEC` и т.п.) → код `126`.

### 7.3 Одиночная команда (без пайпов)

Алгоритм `run_single(CommandSpec)`:

1. Если `is_assignment_only`:
   - применить все присваивания к `Environment::set`;
   - вернуть `exit_code = 0`.
2. Иначе:
   - если builtin:
     - выполнить builtin **в процессе shell** (in-proc), чтобы он мог:
       - завершить REPL (`exit`);
       - (в будущем) менять состояние shell.
     - вернуть код builtin и, если это `exit`, `request_exit=true`.
   - если external:
     - `fork()`
       - в child:
         1) подготовить `envp` из эффективного окружения команды (снимок `Environment` + overlay `prefix_env`, если он непуст);
         2) выполнить резолвинг `argv[0]` по правилам из §7.2.1;
         3) вызвать `execve(resolved_path, argv, envp)` (возврат только при ошибке).
       - в parent: `waitpid`, вернуть код завершения.

Декодирование `status` после `waitpid` (и для одиночной команды, и для pipeline):
- если `WIFEXITED(status)` → `exit_code = WEXITSTATUS(status)`;
- если `WIFSIGNALED(status)` → `exit_code = 128 + WTERMSIG(status)` (как в bash).


### 7.4 Pipeline (N команд)

Pipeline исполняется как набор процессов, соединённых `pipe`.

Для `commands.size() = N`:
- создаются `N-1` pipe'ов;
- каждая команда исполняется в **дочернем процессе**, включая builtins;
- выполняется `dup2` для подключения stdin/stdout;
- родитель закрывает неиспользуемые дескрипторы и ждёт детей.

Пошаговый алгоритм (важно для корректного EOF в пайпах):

1) Создать массив `pipes` длиной `N-1`: каждый элемент — `{read_fd, write_fd}` от `pipe()`.
2) Для каждой команды `i`:
   - вычислить `in_fd`/`out_fd` по схеме ниже;
   - `fork()`:
     - **child**:
       - `dup2(in_fd, STDIN_FILENO)`, `dup2(out_fd, STDOUT_FILENO)` (если нужно);
       - закрыть **все** `read_fd/write_fd` из `pipes` (после `dup2` они больше не нужны);
       - выполнить builtin или external:
         - builtin: вызвать обработчик;
         - external: подготовить `envp` из эффективного окружения команды (снимок `Environment` + overlay `prefix_env`, если он непуст), затем резолвинг и `execve`.
     - **parent**:
       - сразу закрыть те концы pipe'ов, которые этому родителю больше не нужны:
         - write-end `pipe(i)` после форка команды `i` (чтобы читатель следующей команды увидел EOF);
         - read-end `pipe(i-1)` после форка команды `i` (он уже передан в child как stdin следующей команды);
       - сохранить `pid` в список.
3) После запуска всех `N` детей: закрыть оставшиеся open fd у родителя (если вдруг остались) и сделать `waitpid` для каждого `pid`.

#### Подключение потоков
Для команды `i` (0-based):
- `in_fd`:
  - если `i == 0`: `STDIN_FILENO`
  - иначе: read-end pipe(i-1)
- `out_fd`:
  - если `i == N-1`: `STDOUT_FILENO`
  - иначе: write-end pipe(i)

В child:
- `dup2(in_fd, STDIN_FILENO)` (если отличается)
- `dup2(out_fd, STDOUT_FILENO)` (если отличается)
- закрыть все pipe fds (оба конца), чтобы не было зависаний из-за открытых write-end.

#### Builtins в pipeline
Builtin внутри pipeline исполняется в child:
- чтобы stdout/stdin корректно шли по pipe;
- чтобы `exit` не завершал родителя.

#### Assignment-only в pipeline и влияние на Environment
Если элемент pipeline является `is_assignment_only == true`, то он исполняется в **дочернем процессе**:
- присваивания применяются к локальной копии окружения процесса child;
- после этого child завершается с кодом `0`.

Важно: такие присваивания **не меняют** `Environment` интерпретатора (родителя) и **не видны** другим командам pipeline, так как каждая команда выполняется в отдельном процессе.

#### Возврат кода pipeline
Родительский процесс **ожидает завершения всех дочерних процессов** (`waitpid` для каждого pid).
Код завершения pipeline равен коду завершения **последней команды** (как в большинстве shell), вычисленному по правилам декодирования `waitpid` выше (обычный `exit status` или `128 + signal`).

### 7.5 Разделение аргументов и входного потока

- `argv` — список аргументов команды, формируется Frontend.
- stdin — поток данных для команд в пайпе.

Реализация builtins следует правилам:
- `echo`: печатает `argv[1..]`, stdin не читает.
- `pwd`: печатает текущую директорию, stdin не читает.
- `cat`:
  - если есть имена файлов в `argv[1..]` — печатает их содержимое;
  - иначе читает stdin и пишет в stdout (нужно для пайпов).
- `wc`:
  - если указан ровно один файл в `argv[1]` — считает по файлу;
  - если файлов больше одного — stderr и код ошибки (рекомендуемо `2`) *(упрощение v1)*;
  - иначе читает stdin и считает.
- `exit`:
  - если есть `argv[1]` — трактует как целое 0..255 (при ошибке → код 2);
  - устанавливает `request_exit=true` только при одиночном исполнении (in-proc).

## 8. BuiltinRegistry и расширяемость

### 8.1 Цель

Добавление новой встроенной команды сводится к:
- реализации функции-обработчика;
- регистрации в `BuiltinRegistry`;
без изменений в Frontend/Executor (кроме списка регистраций при старте).

### 8.2 Интерфейс реестра

```cpp
using BuiltinFn = std::function<int(const std::vector<std::string>& argv,
                                    Environment& env)>;

class BuiltinRegistry {
public:
    void register_cmd(std::string name, BuiltinFn fn);
    BuiltinFn* find(const std::string& name);

private:
    std::unordered_map<std::string, BuiltinFn> map_;
};
```

Обоснование I/O для builtins:
- для пайплайнов `Executor` настраивает stdin/stdout через `dup2` **до** запуска команды;
- builtin-обработчики работают с `STDIN_FILENO` / `STDOUT_FILENO` через POSIX `read/write`;
- так пайпы работают одинаково для builtins и внешних программ;
- ответственность за потоки единая и находится в `Executor`.



## 9. Обработка ошибок и коды возврата

### 9.1 Ошибки Frontend
- незакрытые кавычки → сообщение в stderr, `exit_code = 2`;
- некорректный pipe (`|` без команды слева/справа) → stderr, `exit_code = 2`.

Frontend возвращает ошибку в структурированном виде (например, `expected<Pipeline, ParseError>`), а REPL печатает её.

### 9.2 Ошибки выполнения
Рекомендованная политика кодов (приближённая к shell-практике):
- неизвестная команда (не builtin, `exec` не найден) → `127`;
- `exec` найден, но не запускается (permission и т.п.) → `126` (допускается упростить до `127`, но лучше различать);
- ошибки builtins (файл не найден для `cat`, `wc`) → `1`;
- некорректный аргумент `exit` → `2`.

### 9.3 Вывод ошибок
- ошибки печатаются в stderr (fd `2`);
- формат: `<cmd>: <message>\n`.

## 10. Поток исполнения (traceability)

### 10.1 Точка входа

`main()`:
1. создаёт `Environment` из `environ`;
2. создаёт `BuiltinRegistry` и регистрирует `cat/echo/wc/pwd/exit`;
3. создаёт `ShellApp` и вызывает `run()`.

### 10.2 Главный цикл REPL

`ShellApp::run()`:
1. выводит prompt (`> `);
2. читает строку; при EOF завершает цикл REPL (без вызова `exit` builtin).
   Код завершения процесса shell равен `last_exit_code` (или `0`, если ещё ничего не выполнялось);
3. вызывает `Frontend::parse(line, env)`:
   - пустая строка → continue;
   - ошибка → печатает, continue;
4. вызывает `Executor::run(pipeline, env)`:
   - получает `ExecResult`;
   - если `request_exit` → завершает цикл; процесс shell завершается с кодом `ExecResult.exit_code`.
   - опционально сохраняет `last_exit_code`.

## 11. Взаимодействие с POSIX: процессы и файловые дескрипторы

Ключевые системные вызовы:
- `pipe(int fds[2])` — создание канала;
- `fork()` — создание процесса;
- `dup2(oldfd, newfd)` — переназначение stdin/stdout;
- `close(fd)` — закрытие дескрипторов;
- `execve/execvp` — запуск внешней программы;
- `waitpid(pid, &status, 0)` — ожидание завершения.

Требования к закрытию fd:
- каждый child после `dup2` закрывает все pipe fd, которыми не пользуется;
- parent закрывает write-end pipe после запуска следующего процесса, чтобы читатели получали EOF корректно;
- рекомендуется RAII-обёртка для fd (например, `FdGuard`), чтобы избежать утечек.

## 12. Осознанные упрощения

Чтобы не разрастаться в полноценный bash, фиксируем упрощения:
- нет поддержки экранирования (`\`) и сложных конструкций `${...}`, `$(...)`;
- если `$` не образует корректного имени переменной, он считается обычным символом;
- результат подстановки `$NAME` **не проходит повторное разбиение на слова** (word splitting не реализован): подстановка всегда происходит внутри уже собираемого `Word` токена;
- нет редиректов `>`, `<`, `>>`;
- нет логических операторов `&&`, `||`;
- нет globbing (`*`, `?`) и job control.

При этом архитектура допускает расширение: добавление новых операторов возможно через расширение Lexer/Parser.

## 13. План тестирования (минимум для реализации)

Тесты делятся по слоям:

**Lexer:**
- кавычки: `'a b'` → `Word("a b")`
- double quotes: `"a $X b"` при `X=1` → `Word("a 1 b")`
- `$` в single quotes: `'$X'` → `Word("$X")`
- pipe inside quotes: `"a|b"` → `Word("a|b")`, без `Pipe`

**Parser:**
- `a | b | c` → 3 `CommandSpec`
- ошибки: `| a`, `a |` → `ParseError`

**Executor (smoke):**
- `echo 123 | wc` → ожидаем `1 1 3`
- `FILE=example.txt` затем `cat $FILE` → печатает содержимое файла
- неизвестная команда `no_such_cmd` → код 127
